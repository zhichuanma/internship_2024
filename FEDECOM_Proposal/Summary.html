<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Summary of FEDECOM_Proposal</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Summary_files/libs/clipboard/clipboard.min.js"></script>
<script src="Summary_files/libs/quarto-html/quarto.js"></script>
<script src="Summary_files/libs/quarto-html/popper.min.js"></script>
<script src="Summary_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Summary_files/libs/quarto-html/anchor.min.js"></script>
<link href="Summary_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Summary_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Summary_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Summary_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Summary_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Summary of FEDECOM_Proposal</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The key point is to understand what this project is aiming to do, what is to be done and what I can contribute.</p>
<section id="motivation-vision" class="level2">
<h2 class="anchored" data-anchor-id="motivation-vision">Motivation &amp; Vision</h2>
<section id="demand" class="level3">
<h3 class="anchored" data-anchor-id="demand">Demand</h3>
<p>The unsatisfactory status of environmental and climate change indicators across the world -&gt; increase the operational costs &amp; capital investments for the energy security in EU -&gt; predict, control and manage intermittent energy sourcing for highly variable load profiles <strong>(load curves)</strong></p>
<p>The core problem is the lack of intergration in local energy systems.</p>
</section>
<section id="solution" class="level3">
<h3 class="anchored" data-anchor-id="solution">Solution</h3>
<p>Sector coupling across energy vectors to introduce additional degrees to introduce additional degrees of freedom for energy conversion and dispatching.</p>
<p><a href="https://www.wartsila.com/insights/article/4-questions-on-sector-coupling"><strong>What is Sector coupling?</strong></a> Sector coupling refers to the close integration of major energy-consumers, such as the heating, transportation, and industrial sectors, with the power producing sector.</p>
<p>“energy dispatch” = “energy distribution adjustment”</p>
<section id="major-carrier" class="level4">
<h4 class="anchored" data-anchor-id="major-carrier">Major carrier</h4>
<p>FEDECOM pursues the idea of <strong>electricity becoming the leading energy carrier</strong>, with power grids as the backbone for the decarbonisation of all energy sectors</p>
</section>
<section id="direct-electrification---direct-use" class="level4">
<h4 class="anchored" data-anchor-id="direct-electrification---direct-use">direct electrification - direct use</h4>
</section>
<section id="indirect-electrification---power-to-x" class="level4">
<h4 class="anchored" data-anchor-id="indirect-electrification---power-to-x">indirect electrification - power to X</h4>
<p>FEDECOM will couple RES, storage and power-to- technologies(same concept with power to X) availale in the pilots (community assets) to ensure efficient, stable and reliable grid operation.</p>
<p>FEDECOM will deliver a scalable and adaptable <strong>cloud-based platform</strong> composed of <strong>analytical, modelling and optimization services</strong> for <strong>planning, supervision and control</strong> of <strong>integrated</strong> local energy systems</p>
</section>
</section>
<section id="the-platform" class="level3">
<h3 class="anchored" data-anchor-id="the-platform">The platform</h3>
<p>FEDECOM will leverage a <strong>multi-layered federated “System of Systems” (SoS) approach</strong> ((privacy preserving)<a href="https://en.wikipedia.org/wiki/Distributed_constraint_optimization"><strong>distributed optimization</strong></a> and analytics)</p>
<p>FEDECOM will firstly conduct a systematic assessment of (countryspecific) operational challenges for integration across RES based energy systems, and deliver a system planning toolbox with consolidated life-cycle assessment methodology for sector coupling.</p>
<p>As one of the core R&amp;D contributions of the project, FEDECOM will integrate, advance and deploy a cloud-based platform hosting a set of analytical services with predictive, modelling and optimization capabilities to enable cost-optimised and flexible energy system of systems (SoS), leveraging multi-user energy exchange and cross-vector optimization.</p>
<p><strong>measure - forecast - optimise - control</strong> energy savings, reduction of GHG, energy cost reduction</p>
<p>Verified in 3 real large-scale pilots: Spanish Virtual Green H2 Federation, Swiss Residential Hydropower Federation and BENElux cross-country eMobility Federation</p>
</section>
</section>
<section id="excellence" class="level2">
<h2 class="anchored" data-anchor-id="excellence">Excellence</h2>
<section id="objectives-and-ambition" class="level3">
<h3 class="anchored" data-anchor-id="objectives-and-ambition">Objectives and ambition</h3>
<ul>
<li>GO1: Integrate exsiting and emerging ICT tools, deploy cloud-based solution, integrate energy systemsbased on sector coupling, distributed generation and storage, high demand flexibility services</li>
<li>GO2: validate with 3 large-scale pilots</li>
<li>GO3: develop plans for 3 follower communities</li>
</ul>
<section id="sto" class="level4">
<h4 class="anchored" data-anchor-id="sto">STO</h4>
<p>STO 1. enable energy sector coupling through optmised operations and intergration of local energy systems.</p>
<p>STO 2. Increase local RES hosting capacity via improved energy asset scheduling and cross-vector integration.</p>
<p>STO 3: Unlock the demand-side flexibility across federated energy communities to enhance the overall grid operation.</p>
<p><strong>STO 4: Improve long-term planning of sector coupling and integration with RES production sites.</strong></p>
<p>FEDECOM will deliver a comprehensive system planning toolbox, <strong>EnergyScope TD</strong> will be used.</p>
<p>energy dispatch model will be developped and coupled with <strong>EnergyScope TD</strong></p>
<p><em>Actions and projects outcomes:</em></p>
<ul>
<li><p>Deploy long-term planning tool based on the EnergyScope TD model</p></li>
<li><p>Provide optimal design of the system (technology selection, sizing, location)</p></li>
<li><p>Develop energy dispatch model</p></li>
<li><p>Couple with EnergyScope MC for multi-cell planning and assessment</p></li>
</ul>
<p><strong>STO5: Develop consolidated methodology to evaluate interaction and flexibility of coupled energy networks.</strong></p>
<p>FEDECOM will incorporate a consolidated life-cycle assessment methodology to evaluate impact on OPEX and CAPEX, as well as environmental impact, owing to the joint flexibility of integrated energy vectors, energy storage and relevant conversion processes. MCDA will be used.</p>
<p><em>Actions and project outcomes:</em></p>
<ul>
<li><p>Develop a life-cycle assessment methodology of integrated networks</p></li>
<li><p>Integrate techno-economic (LCC) and environmental (LCA) analyses</p></li>
<li><p>Evaluate joint flexibility potential of energy conversion and storage</p></li>
<li><p>Incorporate MCDA for ranking of system configuration alternatives</p></li>
</ul>
<p>STO6: Large-scale pilots as case studies and early adopters.</p>
<p>STO7: Showcase effective business models upon multi-stakeholder open marketplace.</p>
</section>
<section id="expected-results" class="level4">
<h4 class="anchored" data-anchor-id="expected-results">Expected results</h4>
<ul>
<li>planning toolbox</li>
<li>consolidated methodology</li>
<li>MCDA recommender</li>
</ul>
</section>
</section>
</section>
<section id="takeaway" class="level2">
<h2 class="anchored" data-anchor-id="takeaway">Takeaway</h2>
<p>The FEDECOM is a huge sector coupling project and it aims to develop a cloud-based platform following the multilayered federated SoS approach which could do iterative measurement - prediction - optimization - controlling loop in order to reduce the cost and environmental impacts meanwhile fullfill the demands profile.</p>
<p>We mainly focuses on the optimization part. We are supposed to develop a planning toolbox based on Energyscope TD for performing LCC and LCA assessment of different RES-based system configurations, integrate consolidated life-cycle assessment methodology and incorporate MCDA for ranking of system configuration alternatives.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>